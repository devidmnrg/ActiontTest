{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "o8DmkXII9GxB"
      },
      "source": [
        "# OBJECTIVE:\n",
        "# TO BUILD A RECOMMENDATION SYSTEM TO RECOMMEND MOVIES TO USER BASED ON THEIR PREVIOUS HISTORY OF MOVIES WATCHED BY THEM AND THE RATING WHICH THEY HAVE PROVIDED\n",
        "\n",
        "\n",
        "# WE WILL BE USING MOVIE LENS DATASET\n",
        "# YOU CAN DOWNLOAD DATASET FROM HERE: https://www.kaggle.com/grouplens/movielens-20m-dataset\n",
        "# WE WILL BE BUILD THE RECOMMENDATION SYSTEM USING NEURAL COLLABORATIVE FILTERING"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 10,
      "metadata": {
        "id": "_PXu4SitJVpl"
      },
      "outputs": [],
      "source": [
        "#loading the dependencies\n",
        "import numpy as np\n",
        "import tensorflow as tf\n",
        "import pandas as pd\n",
        "import matplotlib.pyplot as plt\n",
        "from tensorflow.keras.models import Sequential,Model\n",
        "from tensorflow.keras.layers import *\n",
        "from tensorflow.keras import layers\n",
        "from tensorflow import keras\n",
        "import zipfile\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 11,
      "metadata": {
        "id": "Y0la4azvjvSX",
        "colab": {
          "base_uri": "https://localhost:8080/",
          "height": 315
        },
        "outputId": "2726be6e-facb-444e-c888-e46f031172f2"
      },
      "outputs": [
        {
          "output_type": "error",
          "ename": "FileNotFoundError",
          "evalue": "[Errno 2] No such file or directory: '/content/drive/MyDrive/TA/ml-latest-small.zip'",
          "traceback": [
            "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
            "\u001b[0;31mFileNotFoundError\u001b[0m                         Traceback (most recent call last)",
            "\u001b[0;32m/tmp/ipython-input-2010308884.py\u001b[0m in \u001b[0;36m<cell line: 0>\u001b[0;34m()\u001b[0m\n\u001b[1;32m      1\u001b[0m \u001b[0;31m# EXTRACTING THE FOLDERS FROM THE ZIP FILE\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m----> 2\u001b[0;31m \u001b[0;32mwith\u001b[0m \u001b[0mzipfile\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mZipFile\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m'/content/drive/MyDrive/TA/ml-latest-small.zip'\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m'r'\u001b[0m\u001b[0;34m)\u001b[0m \u001b[0;32mas\u001b[0m \u001b[0mzip_file\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m      3\u001b[0m   \u001b[0mzip_file\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mextractall\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m''\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
            "\u001b[0;32m/usr/lib/python3.12/zipfile/__init__.py\u001b[0m in \u001b[0;36m__init__\u001b[0;34m(self, file, mode, compression, allowZip64, compresslevel, strict_timestamps, metadata_encoding)\u001b[0m\n\u001b[1;32m   1350\u001b[0m             \u001b[0;32mwhile\u001b[0m \u001b[0;32mTrue\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m   1351\u001b[0m                 \u001b[0;32mtry\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m-> 1352\u001b[0;31m                     \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mfp\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mio\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mopen\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mfile\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mfilemode\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m   1353\u001b[0m                 \u001b[0;32mexcept\u001b[0m \u001b[0mOSError\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m   1354\u001b[0m                     \u001b[0;32mif\u001b[0m \u001b[0mfilemode\u001b[0m \u001b[0;32min\u001b[0m \u001b[0mmodeDict\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
            "\u001b[0;31mFileNotFoundError\u001b[0m: [Errno 2] No such file or directory: '/content/drive/MyDrive/TA/ml-latest-small.zip'"
          ]
        }
      ],
      "source": [
        "# EXTRACTING THE FOLDERS FROM THE ZIP FILE\n",
        "with zipfile.ZipFile('/content/drive/MyDrive/TA/ml-latest-small.zip','r') as zip_file:\n",
        "  zip_file.extractall('')"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "k4dxoz8okLuR"
      },
      "outputs": [],
      "source": [
        "# lOADING THE CSV FILE WHICH CONSITS OF RATINGS GIVEN BY USER FOR A MOVIE AND MOVIE DATASET WHICH CONSISTS ON MOVIE NAME AND ID\n",
        "rating = pd.read_csv(\"/content/drive/MyDrive/MovieLens/rating.csv\")\n",
        "movie = pd.read_csv(\"/content/drive/MyDrive/MovieLens/movie.csv\")"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "vexZRMRYkKxx"
      },
      "outputs": [],
      "source": [
        "print(rating.shape,movie.shape)\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "SzedLQzLkfJ-"
      },
      "outputs": [],
      "source": [
        "rating.head()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "iI3LlKh9kh2K"
      },
      "outputs": [],
      "source": [
        "movie.head()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "r14LqaegYUGZ"
      },
      "outputs": [],
      "source": [
        "rating = rating[0:110000]\n",
        "movie = movie[0:110000]"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "TKcb2ZA4Eftt"
      },
      "outputs": [],
      "source": [
        "# from the rating dataset will retrieve all the unique usersid\n",
        "\n",
        "user_ids = rating['userId'].unique().tolist()\n",
        "user2user = {x: i for i, x in enumerate(user_ids)}\n",
        "userencodeduser = {i: x for i, x in enumerate(user_ids)}"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "6RikxbWZjrFX"
      },
      "outputs": [],
      "source": [
        "print(user_ids)\n",
        "print(user2user)\n",
        "print(userencodeduser)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "7zfcMF6CjyNR"
      },
      "outputs": [],
      "source": [
        "rating.shape"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "3b2jz9VJj6aX"
      },
      "outputs": [],
      "source": [
        "# FROM THE RATING FILE WE WILL RETRIEVE ALL THE UNIQUE MOVIE ID AND USE ENUMERATE TO MAP EACH ID TO A KEY\n",
        "movie_ids = rating['movieId'].unique().tolist()\n",
        "movie2movie = {x: i for i, x in enumerate(movie_ids)}\n",
        "movieencodemovie = {i: x for i, x in enumerate(movie_ids)}"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "5D4vWASr4I-M"
      },
      "outputs": [],
      "source": [
        "rating['user'] = rating['userId'].map(user2user)\n",
        "rating['movie'] = rating['movieId'].map(movie2movie)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "AOJFwEEY4f8c"
      },
      "outputs": [],
      "source": [
        "rating.head()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "h0l0AgBG5KjJ"
      },
      "outputs": [],
      "source": [
        "# FINDING THE MINIMUM AND MAXIMUM RATING GIVEN BY A USER\n",
        "min_rating = min(rating['rating'])\n",
        "max_rating = max(rating['rating'])"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "VutiejGR4hGL"
      },
      "outputs": [],
      "source": [
        "\n",
        "num_users = len(user2user)\n",
        "num_movies = len(movie2movie)\n",
        "rating['rating'] = rating['rating'].values.astype(np.float32)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "Hst3Yw6W5y62"
      },
      "outputs": [],
      "source": [
        "print(\"Number of users : {}, Number of Movies: {}, Min rating: {}, Max rating: {}\".format(num_users,num_movies,min_rating,max_rating))"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "g71TV2BG6xDz"
      },
      "outputs": [],
      "source": [
        "# Train-Test Split\n",
        "rating = rating.sample(frac = 1, random_state = 42) #randomly sample the dataset\n",
        "x = rating[['user','movie']].values\n",
        "# Normalize the target between 0 and 1\n",
        "y = rating['rating'].apply(lambda x: (x - min_rating)/ (max_rating - min_rating)).values"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "Tm77ldqF7xBd"
      },
      "outputs": [],
      "source": [
        "# Assuming training on 90% of the data and validation on 10%\n",
        "train_indicies = int(0.9 * rating.shape[0])"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "SqBrQ2jL7_dR"
      },
      "outputs": [],
      "source": [
        "# Splitting our dataset into features and target variables\n",
        "x_train,x_test,y_train,y_test = (x[:train_indicies],\n",
        "                                 x[train_indicies:],\n",
        "                                 y[:train_indicies],\n",
        "                                 y[train_indicies:])"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "eeIKoYXs8Rn-"
      },
      "outputs": [],
      "source": [
        "x_train.shape"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "LysCNdhO8UDs"
      },
      "outputs": [],
      "source": [
        "y_train.shape"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "OQibKXEp8uxT"
      },
      "outputs": [],
      "source": [
        "# Defining the model\n",
        "embed_size = 50 #embedding size we need\n",
        "user_input = layers.Input(shape = [1])\n",
        "user_embed = layers.Embedding(num_users,embed_size,embeddings_initializer =\"he_normal\",embeddings_regularizer=keras.regularizers.l2(1e-6))(user_input)\n",
        "# Emedding Layer will create 610 vectors look-up table of 50 dimension each\n",
        "user_vect = layers.Flatten()(user_embed)\n",
        "\n",
        "movie_input = layers.Input(shape = [1])\n",
        "movie_embed = layers.Embedding(num_movies,embed_size,embeddings_initializer =\"he_normal\",embeddings_regularizer=keras.regularizers.l2(1e-6))(movie_input)\n",
        "movie_vect = layers.Flatten()(movie_embed)\n",
        "\n",
        "prod = layers.dot(inputs = [user_vect, movie_vect], axes = 1)\n",
        "\n",
        "dense1 = layers.Dense(150,activation='relu', kernel_initializer=\"he_normal\")(prod)\n",
        "dense2 = layers.Dense(64,activation='relu', kernel_initializer=\"he_normal\")(dense1)\n",
        "dense3 = layers.Dense(1,activation='relu')(dense2)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "1Uxp-KWQY3AD"
      },
      "outputs": [],
      "source": [
        "# BUILDING OUR MODEL\n",
        "model = Model([user_input, movie_input], dense3)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "fZsAX9HvauEe"
      },
      "outputs": [],
      "source": [
        "# COMPILING THE MODEL\n",
        "model.compile(optimizer = 'adam',loss = 'mean_squared_error')"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "x-pnkdUha7pR"
      },
      "outputs": [],
      "source": [
        "keras.utils.plot_model(model,show_shapes = True)"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "1_JsbonI_Kbe"
      },
      "source": [
        "#TRAINING OUR MODEL"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "KYk35RlsbBbY"
      },
      "outputs": [],
      "source": [
        "%%time\n",
        "history = model.fit([x_train[:,0],x_train[:,1]], y_train, batch_size = 32, epochs = 10, verbose = 1) # here we will be sending user_id and movie_id as inputs"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "x_8OqqYaASYf"
      },
      "outputs": [],
      "source": [
        "prediction = model.evaluate([x_test[:,0],x_test[:,1]])"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "cXxH9fKBbk0Y"
      },
      "outputs": [],
      "source": [
        "pred = model.predict([x_train[4:5,0],x_train[4:5,1]])\n",
        "pred"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "i02QVQ2EiHoj"
      },
      "outputs": [],
      "source": [
        "movie.shape"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "vNDdWm6RBZ6t"
      },
      "source": [
        "# getting 1 random user id and recommending that user top 10 movies based on that user ratings and the movies watched by him"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "XIEFf9_Ic4XC"
      },
      "outputs": [],
      "source": [
        "user_id = rating.userId.sample(1).iloc[0]  # getting 1 random user id\n",
        "movies_watched_by_user = rating[rating.userId == user_id] #filtering out the movies watched by user\n",
        "movies_not_watched = movie[~movie[\"movieId\"].isin(movies_watched_by_user.movieId.values)][\"movieId\"] #getting the movies which are not watched by the user"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "VAHE17cPduoj"
      },
      "outputs": [],
      "source": [
        "user_id # here the userId is 387"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "BO7goOtGdv4v"
      },
      "outputs": [],
      "source": [
        "movies_watched_by_user.head()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "lrBg9P98d28a"
      },
      "outputs": [],
      "source": [
        "movies_not_watched"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "MYqcbmTgeJF4"
      },
      "outputs": [],
      "source": [
        "#this is an innerjoin between movies_not_watched and movie ids from rating table (to check whether the movie ids are not out of place)\n",
        "movies_not_watched = list(\n",
        "    set(movies_not_watched).intersection(set(movie2movie.keys()))\n",
        ")"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "KBpJDhwmevFI"
      },
      "outputs": [],
      "source": [
        "movies_not_watched"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "rqhTGGGLzXTf"
      },
      "outputs": [],
      "source": [
        "max(movies_not_watched)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "TcGJ1bXpewj6"
      },
      "outputs": [],
      "source": [
        "movies_not_watched_index = [[movie2movie.get(x)] for x in movies_not_watched] # get the indexes of the movies not watched by the user which we will use later for recommending\n",
        "movies_not_watched_index"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "9ubrsmWAfC8U"
      },
      "outputs": [],
      "source": [
        "user_encoder = userencodeduser.get(user_id)\n",
        "user_encoder"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "wZNW4WuwZykk"
      },
      "outputs": [],
      "source": [
        "# Stacking the userid with respect to the movie not watched by the user\n",
        "user_movie_array = np.hstack(([[user_encoder]] * len(movies_not_watched), movies_not_watched_index))\n",
        "user_movie_array"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "b2vOl-Bw6R5V"
      },
      "outputs": [],
      "source": [
        "# we will do the prediction of the user 387 and predicting the rating which the user may give based on his previous history of rating\n",
        "ratings = model.predict([user_movie_array[:,0],user_movie_array[:,1]]).flatten()\n",
        "ratings"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "KLkAjZK5aKd2"
      },
      "outputs": [],
      "source": [
        "top_ratings_indices = ratings.argsort()[-10:][::-1] #indices of highest 10 ratings\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "LHxAnnG3ardk"
      },
      "outputs": [],
      "source": [
        "# getting the id of movies which our model has predicted for the particular user\n",
        "recommended_movie_ids = [movieencodemovie.get(movies_not_watched_index[x][0]) for x in top_ratings_indices]"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "sVGN-LBQbC4p"
      },
      "outputs": [],
      "source": [
        "print(\"Showing recommendations for user: {}\".format(user_id))\n",
        "print(\"====\" * 9)\n",
        "print(\"Movies with high ratings from user\")\n",
        "print(\"----\" * 8)\n",
        "top_movies_user = (\n",
        "    movies_watched_by_user.sort_values(by=\"rating\", ascending=False)\n",
        "    .head(5)\n",
        "    .movieId.values\n",
        ")\n",
        "movie_df_rows = movie[movie[\"movieId\"].isin(top_movies_user)]\n",
        "for row in movie_df_rows.itertuples():\n",
        "    print(row.title, \":\", row.genres)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "3QoVXvUUfe0-"
      },
      "outputs": [],
      "source": [
        "print(\"----\" * 8)\n",
        "print(\"Top 10 movie recommendations\")\n",
        "print(\"----\" * 8)\n",
        "recommended_movies = movie[movie[\"movieId\"].isin(recommended_movie_ids)]\n",
        "for row in recommended_movies.itertuples():\n",
        "    print(row.title, \":\", row.genres)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "R-yDcGLgfqxh"
      },
      "outputs": [],
      "source": []
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "zW4TCzaVi5jn"
      },
      "outputs": [],
      "source": []
    }
  ],
  "metadata": {
    "accelerator": "GPU",
    "colab": {
      "name": "Recommendation System .ipynb",
      "provenance": []
    },
    "kernelspec": {
      "display_name": "Python 3 (ipykernel)",
      "language": "python",
      "name": "python3"
    },
    "language_info": {
      "codemirror_mode": {
        "name": "ipython",
        "version": 3
      },
      "file_extension": ".py",
      "mimetype": "text/x-python",
      "name": "python",
      "nbconvert_exporter": "python",
      "pygments_lexer": "ipython3",
      "version": "3.11.5"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 0
}